---
layout: post
title:  "Rust, WASM, Tauri, ROS2, CR in Swarm Robotics; REV 00.01.00"
subtitle:  "Developing The Accelerated Immersive Learning Process"
date:   2024-03-01 4:29:00
categories: template
---

The goal is to provide a comprehensive, but not exhaustive, curriculum that will enable the learner to build a solid foundation in Rust-Lang, WebAssembly, Tauri, ROS2, and distributed systems.

It is intended to be an intensive, immersive, yet thorough and well-rounded curriculum to provide the foundational skills for a goal of building fault-tolerant real-time operating systems for robot swarms. 

As we go along through this material, we will want to be searching extensively, exhaustively for inexpensive demonstration or prototype-level projects and development communities that are working in areas tangentially related to the theoretical study outlined in this syllabus. Of course, the exact content for any self-starting autodidact can be adapted based on that individual's prior experience and their specific learning requirements. 

# Fundamentals (50 modules):

0: **Before we EVEN start** down the Rust-Lang portion of this program of study, it's spend some time [carefully reviewing the reasons WHY anyone would want to use Rust-Lang](https://g.co/gemini/share/539967298e84) ... maybe, we will come away from this thinking that this course should really be much more heavily based on C-Lang, although we will get into plenty of legacy C code along the way, as we work through examples and ask our AI assistants to help us understand why something is done as it is in C-Lang. [C-Lang is likely to remain the dominant force in low-level programming long into the foreseeable future](https://g.co/gemini/share/87dc72e2cb30). 

Rust-Lang is offering seriously compelling advantages over C-Lang in some aspects, since memory safety is going to remain one of the most significant concerns in programming. That has been recognized for some time [thus Rust-Lang came into existence], but many writing code in the C programming language, even if the C standard does not [in its current form] inherently provide memory safety. The responsibility of ensuring memory safety in C largely falls on the C developer, but that will change with standards and automation. The C-Lang developer can use C development tools that aid in memory safety; there are scads of bright people working on changes to C [driven by memory safety issue] to the language/compiler and libraries. 

It's certainly not foolproof, BUT ***developing memory safe code is not impossible*** ... for example, [packaging several features into profilers can do ***much*** [although far from everything that Rust-Lang does] to enforce memory safety](https://g.co/gemini/share/c49b6967474b). Developers can follow certain practices [and set up their toolchains accordingly] to achieve memory safety, such as: a) [nulling out pointers when freeing memory to avoid Use-After-Free bugs and double free bugs](https://g.co/gemini/share/ff0bed4ab86e), b) [performing bound checks to avoid Out-Of-Bounds (OOB) read and write vulnerabilities](https://g.co/gemini/share/39a0c582ef8f). c) [avoiding recursion or using it within known limits to prevent Stack Exhaustion and Heap Exhaustion vulnerabilities](https://g.co/gemini/share/cad42032c5d4). Although *practices* can help, they do not guarantee memory safety to the degree that Rust-Lang can. 

The thing is, there's a **LOT** of C code out there already and it's not going away soon, partly because ***even*** [high-level programming will not soon be replaced by conversational AI](https://g.co/gemini/share/de1515337e6c), there will always be important niches where C's raw control and established ecoystem are irreplaceable for troubleshooting issues in low-level programming. It is probably worth going down the Rust-Lang path as a novice or journeyman, even if one does not start out with an aim for mastery. 

It's not really about the C vs Rust programming language argument ... because we all need to be *conversant* in different languages and idioms ... it's the interactions with the larger POPULATION of developers writing code that matters. It is strongly recommended that one working in this area engage in [literate programming](https://en.wikipedia.org/wiki/Literate_programming) to communicate ideas. One example of this idea of being enough of a polyglot to be able to communicate the dangerous gist of an idea to others is [.NET Interactive](https://github.com/dotnet/interactive) and [**POLYGLOT** ***notebookers***](https://code.visualstudio.com/docs/languages/polyglot) which allow us to programmatically demonstrate ideas and use [diagrams-as-code](https://github.com/topics/diagrams-as-code?o=desc&s=forks) tools like [Mermaid](https://mermaid.js.org/intro/) for [sankey flow diagrams](https://mermaid.js.org/syntax/sankey.html), [gitgraphs](https://mermaid.js.org/syntax/gitgraph.html), [mind maps](https://mermaid.js.org/syntax/mindmap.html). 

There are interesting and important conversations happening now in areas like machine learning, AI and large language models that really sort of call for one at least being able to follow [and ask useful clarifying questions in] a serious discussion happening in some corner of the larger polyglot ecosystem ... when it comes to learning languages ***which is really about understanding how people who express ideas in those languages think***, we will want to think about those ways for [expeditiously ascending the Rust-Lang learning curve](https://g.co/gemini/share/3c9d44a968dc) that make the most sense for us in IMMERSING ourselves in the language and getting up to speed as rapidly as possible.

1: [Preliminaries: Basic Installation](https://doc.rust-lang.org/book/ch01-01-installation.html) ... start with the normally recommended [rustup](https://rust-lang.github.io/rustup/concepts/index.html) basic installation process and invoke [rustc](https://doc.rust-lang.org/rustc/what-is-rustc.html) to compile and then run the ["Hello, World!" example](https://doc.rust-lang.org/rust-by-example/hello.html), which means that you need to ensure that you have everything ready to go. At first, you're just going to get a start with Rust program anatomy, including things like [comments](https://doc.rust-lang.org/rust-by-example/hello/comment.html) or additional *junk* code you care to add, just to monkey around ... the NECESSITY of monkeying around with the hello_world program can't be stressed enough; after all, this is a just sandbox; so [read ahead to *learn ahead of the class*, do things when you don't know what you're doing, look over other examples upon [Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html)] but, be sure to add stupid stuff and find different ways to ***break*** the simple program.You want to come away from this with some vague sense of how Rust checks formatting correctness at compile time, noting that Rust is an ahead-of-time compiled language and uses linters. You will especially want to notice *and break* the syntax of main() function with the body wrapped in {} and the [formatted print](https://doc.rust-lang.org/rust-by-example/hello/print.html). 

Add different kinds of junk filler code ... just to experimenting a bit with [rustfmt](https://github.com/rust-lang/rustfmt) tool for formatting Rust code according to style guidelines. But also take a quick overview look at the other [Rust development tools](https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html) such as [rustfix](https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html#fix-your-code-with-rustfix) and [rust-clippy tool](https://doc.rust-lang.org/clippy/index.html), with its collection of [over 700 lints](https://rust-lang.github.io/rust-clippy/master/index.html). You can master these ***later***, but at first you want to RAPIDLY get a very high level overview of the [rust-analyzer extension for VSCode](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) as well as other Rust-related extensions for VSCode, such as [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb) and by all means if you use VSCode, be SURE to ALSO work through [the tutorial for using Rust within VSCode](https://code.visualstudio.com/docs/languages/rust) to *start* getting a sense of how you might eventually get a feel for [how VSCode can be used for Rust development](https://g.co/gemini/share/1526dd613f89). 

Be sure to compile and run trial example programs beyond just [Hello, World!](https://doc.rust-lang.org/rust-by-example/hello.html). Then experiment with Rust's [Cargo build system and package manager](https://doc.rust-lang.org/book/ch01-03-hello-cargo.html) and skim over [The Cargo Book](https://doc.rust-lang.org/cargo/). The POINT of getting way ahead of yourself in the **Preliminary** module is to go wild, explore how much you can learn in just one day ... don't worry about getting it down perfectly, you will not have ***really*** broken anything -- we will be coming back to this material again and again ... at first, just install Rust, compile and run the hello_world program, drink from the firehose and ... ***BREAK THINGS.***

2-10: Start scratching the surface of how Rust actually works by methodically going through each one of the exercises in [rustlings](https://github.com/rust-lang/rustlings/) the *right way* ... because [rustlings](https://github.com/rust-lang/rustlings/) is going to be the best way for large audiences of Rust noobs to assuredly learn the most basic basics of fundamental programming in Rust. While you are going through the exercises, you will want to use [***The Rust Programming Language*** book](https://doc.rust-lang.org/book/index.html), the most comprehensive and theoretically deep resource for exploring concepts. You will also want to rely upon [Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html) for practical ideas for alternative examples to tie all of the concepts together so that you might firmly understand [common programming concepts, keywords and syntax](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html),[variables and mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html), [data types](https://doc.rust-lang.org/book/ch03-02-data-types.html), [functions](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html), [comments](https://doc.rust-lang.org/book/ch03-04-comments.html), [control flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html).

11-20: [Resource Acquisition Is Initialization(RAII)](https://doc.rust-lang.org/rust-by-example/scope/raii.html) [ownership and moves](https://doc.rust-lang.org/rust-by-example/scope/move.html), [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html), [lifetimes](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html) 
21-30: [Structs](https://doc.rust-lang.org/book/ch05-00-structs.html), [enums and pattern matching](https://doc.rust-lang.org/book/ch06-00-enums.html)

31-35: Error handling, Option, Result 

36-40: Modules, crates, workspaces

41-45: Testing, debugging, documentation

46-50: Standard library, common collections

# Systems Programming (40 modules):

VLSI, FPGA, and ASIC design are EXACTLY a big part of this curriculum, but they are important to the development of real-time fault-tolerant systems and communication meshes. Computer architectures are still rapidly evolving, eg witness the rise of HBM3 to get past the Von Nueumann bottleneck and place memory closer to processing units. Accordingly, we delve into different side trips into research topics in computer architectures to ensure that we provide a foundation for understanding the "bare metal" that Rust programs will be getting closer to in the future.

51-60: Memory layout, pointers, unsafe Rust

61-65: Concurrency, threads, sync primitives 

66-70: Parallelism, rayon, crossbeam

71-75: FFI, linking to C code

76-80: Allocators, custom allocators

81-90: Performance, profiling, optimization 

# Embedded & Real-Time Systems (40 modules):

91-100: Embedded basics, no_std, memory-mapped registers

101-105: Interrupts, exceptions, fault handling

106-110: Device drivers, I/O 

111-120: Real-time scheduling, RTOS concepts

121-125: Time handling, clocks, timers

126-130: Predictability, worst-case execution time

# WebAssembly & Tauri (20 modules): 

WebAssembly and Tauri are included to enable UI development and potential off-loading of computation. 

131-135: WebAssembly basics, Rust to WASM

136-140: JavaScript interop, wasm-bindgen

141-145: Tauri fundamentals, project setup

146-150: UI development with Tauri

# Robotics & ROS2 (30 modules):

The robotics portion covers essential concepts and ROS2 integration.

151-160: Robotics fundamentals, kinematics, control

161-165: Sensors, actuators, interfacing

166-170: ROS2 architecture, nodes, topics

171-175: Navigation, path planning, obstacle avoidance 

176-180: Computer vision, image processing

# Distributed Systems And Wireless Networking (20 modules):

These distributed systems modules START to prepare us for the challenges of swarm robotics, such as coordination, resilience, and security.

181-184: [Distributed algorithms](https://arxiv.org/search/?query=Distributed+algorithms&searchtype=all&abstracts=show&order=-submitted_date&size=200), [consensus](https://arxiv.org/search/?query=consensus+algorithm&searchtype=all&source=header), [gossip](https://arxiv.org/search/?query=gossip+algorithm&searchtype=all&source=header)

185-188: Fault tolerance, replication, sharding

189-196: Wireless networking, reliable message passing, standard protocols, [SDR](https://arxiv.org/search/?query=software+defined+radio+SDR&searchtype=all&source=header) and [cognitive radio](https://arxiv.org/search/?query=%22cognitive+radio%22&searchtype=all&source=header), [signal processing research](https://arxiv.org/list/eess.SP/recent)

197-200: It's probably not a bad idea to develop your own prioritized list of some of the best blogs, repositories, newsletters, and other infosec resources to immerse you in the topic of cybersecurity:

1. [Schneier on Security](https://www.schneier.com/) -- Easily the most level-headed and sanely PROFESSIONAL resource on information security. As a general rule, at least one a week or maybe more frequently everyone should read [***Schneier On Security***](https://www.schneier.com/). We all know that infosec is something that we should be more aware of ... the reason that normal, well-adjusted people tend shy away from this topic is that, unfortunately, MOST OF, but not quite all of material on information security is like antivirus software being worse than viruses ... people shy away from infosec blogs because they don't want to catch infosec mindrot. EXCEPT FOR [Schneier on Security](https://www.schneier.com/) most of the ad-heavy content, which inherently needy and likely to be insecure or even quasi-malicious trackering malware, out there is mostly just out-and-out coated in disgusting slop in a stew of fear-mongering grease, ie "*THIS is something you need to be totally terrified of and you're probably already fucked, but it's too slippery for you to grasp, so get yourself some of our X or book me for a seminar immediately.*"

2. [OWASP (Open Web Application Security Project)](https://github.com/OWASP) is a nonprofit foundation with tens of thousands of members working to improve the security of software with community-led open source projects including code, documentation, and standards. Different materials might be particular useful to people trying to learn as much as possible as quickly as possible about security. OWASP provides a wealth of resources, including: [Cheat Sheet Series](https://cheatsheetseries.owasp.org/IndexASVS.html) [Software Assurance Maturity Model](https://owasp.org/www-project-samm/)

3. [HackerRepo.org](https://github.com/The-Art-of-Hacking/h4cker) by [Omar Santos](https://github.com/santosomar) -- includes thousands of resources related to ethical hacking, bug bounties, digital forensics and incident response (DFIR), artificial intelligence security, vulnerability research, exploit development, reverse engineering, and supplemental materials to support the bodies of knowledge for relevant infosec Certifications.

4. [SecLists.Org Security Mailing List Archive](http://seclists.org/) -- everyone knows that the latest news and exploits are not found on any web site. The cutting edge in security research is and will continue to be the full disclosure mailing lists such as Bugtraq. SecLists provides web archives and RSS feeds. You can browse the individual lists or search them all using the Site Search box.

5. [Exploit Database](https://www.exploit-db.com/) non-profit project that is maintained and provided as a public service by the [OffSec training and pentesting company](https://www.offsec.com/products/) as one of its [open source community projects](https://www.offsec.com/community-projects/). 

6. [SANS Internet Storm Center(ISC)](https://isc.sans.edu/), part of the [SANS Technology Institute](https://www.sans.edu/), ISC is a free, community-driven infosec defensive service offering daily diaries, podcasts, and many different initiatives.

7. [Packet Storm Security](https://packetstormsecurity.com/) provides around-the-clock information and tools in order to help mitigate both personal data and fiscal loss on a global scale. As new information surfaces, Packet Storm releases everything immediately through it's RSS feeds, Twitter, and Facebook.



4. [The Hacker News](https://thehackernews.com/)
5. [Threatpost](https://threatpost.com/)


11. Security Weekly - https://securityweekly.com/
12. Risky Business Podcast - https://risky.biz/
13. Troy Hunt's Blog - https://www.troyhunt.com/
14. Graham Cluley - https://grahamcluley.com/
15. Naked Security (Sophos) - https://nakedsecurity.sophos.com/
16. CSO Online - https://www.csoonline.com/
17. Bleeping Computer - https://www.bleepingcomputer.com/
18. Daniel Miessler - https://danielmiessler.com/
19. Reddit r/netsec - https://www.reddit.com/r/netsec/
20. GitHub Security Lab - https://securitylab.github.com/
21. Google Project Zero - https://googleprojectzero.blogspot.com/
22. Microsoft Security Response Center - https://msrc-blog.microsoft.com/
23. AWS Security Blog - https://aws.amazon.com/blogs/security/
24. Black Hat Conference Media - https://www.blackhat.com/html/media.html
25. DEF CON Media Server - https://media.defcon.org/

26. [Krebs on Security](https://krebsonsecurity.com/) covers a wide range of topics, from general security news and analysis to technical details on vulnerabilities, exploits, and defensive measures. 
3. [Dark Reading](https://www.darkreading.com/)

There are different terms and key words that are important in [cybersurity for IoT](https://www.nist.gov/itl/applied-cybersecurity/nist-cybersecurity-iot-program), which is related to but it's focus is necessarily different than [general cybersecurity](https://www.nist.gov/blogs/cybersecurity-insights) which is focused on humans, social engineering, identity theft and malevolent actors that tend to be financially motivated. 

[authentication](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html), [authorization](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html), encryption [digital signatures](https://cloud.google.com/kms/docs/digital-signatures) [cryptographic storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html), [PGP deficiencies](https://www.latacora.com/blog/2019/07/16/the-pgp-problem/) and [why PGP should just die](https://blog.cryptographyengineering.com/2014/08/13/whats-matter-with-pgp/) [signing arbitrary data with your SSH keys](https://www.agwa.name/blog/post/ssh_signatures)

