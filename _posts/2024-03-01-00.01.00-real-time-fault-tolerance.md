---
layout: post
title:  "Rust, WASM, Tauri, ROS2, CR in Swarm Robotics; REV 00.01.00"
subtitle:  "Developing The Accelerated Immersive Learning Process"
date:   2024-03-01 4:29:00
categories: template
---

The goal is to provide a comprehensive, but not exhaustive, curriculum that will enable the learner to build a solid foundation in Rust-Lang, WebAssembly, Tauri, ROS2, and distributed systems.

It is intended to be an intensive, immersive, yet thorough and well-rounded curriculum to provide the foundational skills for a goal of building fault-tolerant real-time operating systems for robot swarms. 

As we go along through this material, we will want to be searching extensively, exhaustively for inexpensive demonstration or prototype-level projects and development communities that are working in areas tangentially related to the theoretical study outlined in this syllabus. Of course, the exact content for any self-starting autodidact can be adapted based on that individual's prior experience and their specific learning requirements. 

# Fundamentals (50 modules):

0: **Before we EVEN start** down the Rust-Lang portion of this program of study, it's spend some time [carefully reviewing the reasons WHY anyone would want to use Rust-Lang](https://g.co/gemini/share/539967298e84) ... it's about more than just [memory safety](https://stanford-cs242.github.io/f19/lectures/06-2-memory-safety.html) ... maybe, we will come away from the Fundamental modules thinking that this course should really be much more heavily based on C-Lang, because we will certainly get into plenty of legacy C code along the way, as we work through examples and ask our AI assistants to help us understand why something is done as it is in C-Lang. This is really more about learning new languages, polyglotism and why things like domain specific langauges matter ... learning Rust is not about how Rust is going to replace [C-Lang as the dominant force in low-level programming ](https://g.co/gemini/share/87dc72e2cb30) anytime in the foreseeable future. 

The following list of domain-specific languages illustrates a wide range of applications, from web development and databases to hardware design, data analysis, infrastructure management, and more. Their relevance and usefulness may vary depending on the specific domain and the evolving technology landscape ... but the key point illustrated by this short list, is that learning *yet another* new language is something we should expect ... learning a compiled, memory-safe language like Rust might have a steeper learning curve, but being able to understand [programming language theory](https://en.wikipedia.org/wiki/Programming_language_theory) has to be one of your meta-competencies.  Hopefully, this listing of just ten different domain-specific languages will illustrate why **we learn different programming langauges [as the need arises] in order to develop our proficiency in learning programming languages**.

1. [SQL](https://g.co/gemini/share/23e89a1407c3) (Structured Query Language): Used for managing and manipulating relational databases.

2. [HTML](https://g.co/gemini/share/0feeb92896c7) (Hypertext Markup Language): The standard markup language for creating web pages and web applications.

3. [CSS](https://g.co/gemini/share/52b945ce0b76) (Cascading Style Sheets): Used for describing the presentation of a document written in HTML or XML.

4. [RegEx](https://g.co/gemini/share/8a292c5af392) (Regular Expressions): A sequence of characters that define a search pattern, used for pattern matching and text processing.

5. [Markdown](https://g.co/gemini/share/5f8116e637af): A lightweight markup language used for formatting plain text documents, often used for documentation and web content, including social dev fora like [GitHub Discussions](https://docs.github.com/en/discussions/guides/best-practices-for-community-conversations-on-github).

6. [LaTeX](https://g.co/gemini/share/5059c75eae18): A document preparation system used for technical and scientific documentation, known for its high-quality typesetting.

7. [VHDL](https://g.co/gemini/share/72c2489fffa9) (VHSIC Hardware Description Language) and [Verilog](https://g.co/gemini/share/b40c7db46a01): Used for describing, designing, verifying digital systems and integrated circuits.

8. [YAML](https://g.co/gemini/share/9a15765609e5) (YAML Ain't Markup Language) or [TOML](https://g.co/gemini/share/9404f8461866) (Tom's Obvious Minimal Language): Human-readable [data serialization formats](https://blog.mbedded.ninja/programming/serialization-formats/a-comparison-of-serialization-formats/) used for [configuration files](https://en.wikipedia.org/wiki/Configuration_file#Comparison) and data exchange.

9. [Gherkin](https://g.co/gemini/share/aabe2674a6d7) or [Rust-rspec]: Describing software **behavior** without detailing how that behavior is implemented in code, used in [Behavior Driven Development (BDD)](https://en.wikipedia.org/wiki/Behavior-driven_development) and [executable specifications written in plain text](https://cucumber.io/docs/guides/overview/)

10. [GraphQL](https://g.co/gemini/share/0a8e4dcbd51c): A data query language developed by Facebook as an alternative to [REST APIs](https://g.co/gemini/share/16e106ce989b) and [ad-hoc webservice architectures](https://g.co/gemini/share/485dab56188a). GraphQL is a strongly typed runtime which allows clients to dictate what data is needed while defining the structure of the data required so that exactly the same structure of the data is returned from the server.

By [solving the memory-challenge](https://arxiv.org/pdf/2003.03296.pdf), Rust-Lang offers a seriously compelling advantage over C-Lang. Memory safety is going to remain one of the most significant concerns in programming and this has been recognized for some time and, thus Rust-Lang and other alternatives sprung into existence. The responsibility of ensuring memory safety in C largely falls on the C developer, but that will change with future C standards and automated dev tools. C-Lang developers can certainly exploit C development tools that aid in memory safety and there are scads of bright people working on changes to C [driven by memory safety issue] to the language/compiler and libraries. 

Placing the responsibility on the developer is obviously far from being foolproof, BUT ***developing memory safe code is not impossible*** ... for example, [packaging several features into profilers can do ***much*** [although far from everything that Rust-Lang does] to enforce memory safety](https://g.co/gemini/share/c49b6967474b). Developers can follow certain practices [and set up their toolchains accordingly] to achieve memory safety, such as: a) [nulling out pointers when freeing memory to avoid Use-After-Free bugs and double free bugs](https://g.co/gemini/share/ff0bed4ab86e), b) [performing bound checks to avoid Out-Of-Bounds (OOB) read and write vulnerabilities](https://g.co/gemini/share/39a0c582ef8f). c) [avoiding recursion or using it within known limits to prevent Stack Exhaustion and Heap Exhaustion vulnerabilities](https://g.co/gemini/share/cad42032c5d4). Although *practices* can help, they do not guarantee memory safety to the degree that Rust-Lang can. 

The thing is, there's a **LOT** of C code out there already and it's not going away soon, partly because ***even*** [high-level programming will not soon be replaced by conversational AI](https://g.co/gemini/share/de1515337e6c), there will always be important niches where C's raw control and established ecoystem are irreplaceable for troubleshooting issues in low-level programming. It is probably worth going down the Rust-Lang path as a novice or journeyman, even if one does not start out with an aim for mastery. 

It's not really about the C vs Rust programming language argument ... because we all need to be *conversant* in different languages and idioms ... it's the interactions with the larger POPULATION of developers writing code that matters. It is strongly recommended that one working in this area engage in [literate programming](https://en.wikipedia.org/wiki/Literate_programming) to communicate ideas. One example of this idea of being enough of a polyglot to be able to communicate the dangerous gist of an idea to others is [.NET Interactive](https://github.com/dotnet/interactive) and [**POLYGLOT** ***notebookers***](https://code.visualstudio.com/docs/languages/polyglot) which allow us to programmatically demonstrate ideas and use [diagrams-as-code](https://github.com/topics/diagrams-as-code?o=desc&s=forks) tools like [Mermaid](https://mermaid.js.org/intro/) for [sankey flow diagrams](https://mermaid.js.org/syntax/sankey.html), [gitgraphs](https://mermaid.js.org/syntax/gitgraph.html), [mind maps](https://mermaid.js.org/syntax/mindmap.html). 

There are interesting and important conversations happening now in areas like machine learning, AI and large language models that really sort of call for one at least being able to follow [and ask useful clarifying questions in] a serious discussion happening in some corner of the larger polyglot ecosystem ... when it comes to learning languages ***which is really about understanding how people who express ideas in those languages think***, we will want to think about those ways for [expeditiously ascending the Rust-Lang learning curve](https://g.co/gemini/share/3c9d44a968dc) that make the most sense for us in IMMERSING ourselves in the language and getting up to speed as rapidly as possible.

1: [Preliminaries: Basic Installation](https://doc.rust-lang.org/book/ch01-01-installation.html) ... start with the normally recommended [rustup](https://rust-lang.github.io/rustup/concepts/index.html) basic installation process and invoke [rustc](https://doc.rust-lang.org/rustc/what-is-rustc.html) to compile and then run the ["Hello, World!" example](https://doc.rust-lang.org/rust-by-example/hello.html), which means that you need to ensure that you have everything ready to go. At first, you're just going to get a start with Rust program anatomy, including things like [comments](https://doc.rust-lang.org/rust-by-example/hello/comment.html) or additional *junk* code you care to add, just to monkey around ... the NECESSITY of monkeying around with the hello_world program can't be stressed enough; after all, this is a just sandbox; so [read ahead to *learn ahead of the class*, do things when you don't know what you're doing, look over other examples upon [Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html)] but, be sure to add stupid stuff and find different ways to ***break*** the simple program.You want to come away from this with some vague sense of how Rust checks formatting correctness at compile time, noting that Rust is an ahead-of-time compiled language and uses linters. You will especially want to notice *and break* the syntax of main() function with the body wrapped in {} and the [formatted print](https://doc.rust-lang.org/rust-by-example/hello/print.html). 

Add different kinds of junk filler code ... just to experimenting a bit with [rustfmt](https://github.com/rust-lang/rustfmt) tool for formatting Rust code according to style guidelines. But also take a quick overview look at the other [Rust development tools](https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html) such as [rustfix](https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html#fix-your-code-with-rustfix) and [rust-clippy tool](https://doc.rust-lang.org/clippy/index.html), with its collection of [over 700 lints](https://rust-lang.github.io/rust-clippy/master/index.html). You can master these ***later***, but at first you want to RAPIDLY get a very high level overview of the [rust-analyzer extension for VSCode](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) as well as other Rust-related extensions for VSCode, such as [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb) and by all means if you use VSCode, be SURE to ALSO work through [the tutorial for using Rust within VSCode](https://code.visualstudio.com/docs/languages/rust) to *start* getting a sense of how you might eventually get a feel for [how VSCode can be used for Rust development](https://g.co/gemini/share/1526dd613f89). 

Be sure to compile and run trial example programs beyond just [Hello, World!](https://doc.rust-lang.org/rust-by-example/hello.html). Then experiment with Rust's [Cargo build system and package manager](https://doc.rust-lang.org/book/ch01-03-hello-cargo.html) and skim over [The Cargo Book](https://doc.rust-lang.org/cargo/). The POINT of getting way ahead of yourself in the **Preliminary** module is to go wild, explore how much you can learn in just one day ... don't worry about getting it down perfectly, you will not have ***really*** broken anything -- we will be coming back to this material again and again ... at first, just install Rust, compile and run the hello_world program, drink from the firehose and ... ***BREAK THINGS.***

2-10: Start scratching the surface of how Rust actually works by methodically going through each one of the exercises in [rustlings](https://github.com/rust-lang/rustlings/) the *right way* ... because [rustlings](https://github.com/rust-lang/rustlings/) is going to be the best way for large audiences of Rust noobs to assuredly learn the most basic basics of fundamental programming in Rust. While you are going through the exercises, you will want to use [***The Rust Programming Language*** book](https://doc.rust-lang.org/book/index.html), the most comprehensive and theoretically deep resource for exploring concepts. You will also want to rely upon [Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html) for practical ideas for alternative examples to tie all of the concepts together so that you might firmly understand [common programming concepts, keywords and syntax](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html),[variables and mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html), [data types](https://doc.rust-lang.org/book/ch03-02-data-types.html), [functions](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html), [comments](https://doc.rust-lang.org/book/ch03-04-comments.html), [control flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html).

11-20: [Resource Acquisition Is Initialization(RAII)](https://doc.rust-lang.org/rust-by-example/scope/raii.html) [ownership and moves](https://doc.rust-lang.org/rust-by-example/scope/move.html), [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html), [lifetimes](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html) 
21-30: [Structs](https://doc.rust-lang.org/book/ch05-00-structs.html), [enums and pattern matching](https://doc.rust-lang.org/book/ch06-00-enums.html)

31-35: Error handling, Option, Result 

36-40: Modules, crates, workspaces

41-45: Testing, debugging, documentation

46-50: Standard library, common collections

# Systems Programming (40 modules):

VLSI, FPGA, and ASIC design are EXACTLY a big part of this curriculum, but they are important to the development of real-time fault-tolerant systems and communication meshes. Computer architectures are still rapidly evolving, eg witness the rise of HBM3 to get past the Von Nueumann bottleneck and place memory closer to processing units. Accordingly, we delve into different side trips into research topics in computer architectures to ensure that we provide a foundation for understanding the "bare metal" that Rust programs will be getting closer to in the future.

51-60: Memory layout, pointers, unsafe Rust

61-65: Concurrency, threads, sync primitives 

66-70: Parallelism, rayon, crossbeam

71-75: FFI, linking to C code

76-80: Allocators, custom allocators

81-90: Performance, profiling, optimization 

# Embedded & Real-Time Systems (40 modules):

91-100: Embedded basics, no_std, memory-mapped registers

101-105: Interrupts, exceptions, fault handling

106-110: Device drivers, I/O 

111-120: Real-time scheduling, RTOS concepts

121-125: Time handling, clocks, timers

126-130: Predictability, worst-case execution time

# WebAssembly & Tauri (20 modules): 

WebAssembly and Tauri are included to enable UI development and potential off-loading of computation. 

131-135: WebAssembly basics, Rust to WASM

136-140: JavaScript interop, wasm-bindgen

141-145: Tauri fundamentals, project setup

146-150: UI development with Tauri

# Robotics & ROS2 (30 modules):

The robotics portion covers essential concepts and ROS2 integration.

151-160: Robotics fundamentals, kinematics, control

161-165: Sensors, actuators, interfacing

166-170: ROS2 architecture, nodes, topics

171-175: Navigation, path planning, obstacle avoidance 

176-180: Computer vision, image processing

# Distributed Systems And Wireless Networking (20 modules):

These distributed systems modules *START* to prepare us for the challenges of swarm robotics, such as coordination, resilience, and security.

181-186: **Swarm Intelligence**: This sort of transcends the research topic of [distributed algorithms in computer science](https://arxiv.org/search/?query=Distributed+algorithms&searchtype=all&abstracts=show&order=-submitted_date&size=200) and *relatively* basic or fundamental topics like [consensus theory](https://arxiv.org/search/?query=consensus+algorithm&searchtype=all&source=header) or [gossip theory](https://arxiv.org/search/?query=gossip+algorithm&searchtype=all&source=header) and [gossip protocol styles](https://en.wikipedia.org/wiki/Gossip_protocol). It takes us into things like [multi-agent systems](https://en.wikipedia.org/wiki/Multi-agent_system), [crowd simulation](https://en.wikipedia.org/wiki/Crowd_simulation), [complex system topics](https://en.wikipedia.org/wiki/Complex_system) and [complex adaptive systems](https://en.wikipedia.org/wiki/Complex_adaptive_system) made up of intelligent agents such the human social group-based endeavors of [political parties](https://en.wikipedia.org/wiki/Political_party), [communities](https://en.wikipedia.org/wiki/Community), [geopolitical relations](https://en.wikipedia.org/wiki/Geopolitics), [organizations such as companies, institutions or criminal associations](https://en.wikipedia.org/wiki/Organization), [resistance movements](https://en.wikipedia.org/wiki/Resistance_movement) and [leaderless resistance](https://en.wikipedia.org/wiki/Leaderless_resistance), [clandestine cell system](https://en.wikipedia.org/wiki/Clandestine_cell_system), [intelligence tradecraft](https://en.wikipedia.org/wiki/Tradecraft) and war
the categories of topics that fall under the heading [*"network science"*](https://en.wikipedia.org/wiki/Category:Network_science) or [ "social network analysis"](https://en.wikipedia.org/wiki/Category:Social_network_analysis) including things like [sociograms](https://en.wikipedia.org/wiki/Sociogram), [sociomapping](https://en.wikipedia.org/wiki/Sociomapping), [sociometry](https://en.wikipedia.org/wiki/Sociometry), [social dynamics](https://en.wikipedia.org/wiki/Social_dynamics), [social contangion](https://en.wikipedia.org/wiki/Social_contagion), [swarm behavior](https://en.wikipedia.org/wiki/Swarm_behaviour) and [swarm intelligence](https://en.wikipedia.org/wiki/Swarm_intelligence), [shoaling (staying together for social reasons) and schooling(swimming together in a coordinated manner)](https://en.wikipedia.org/wiki/Shoaling_and_schooling), attempts at modeling artificial life with [boids](https://en.wikipedia.org/wiki/Boids) and [self-propelled particles](https://en.wikipedia.org/wiki/Self-propelled_particles)

187-190: Fault tolerance, replication, sharding

191-196: Wireless networking, reliable message passing, standard protocols, [SDR](https://arxiv.org/search/?query=software+defined+radio+SDR&searchtype=all&source=header) and [cognitive radio](https://arxiv.org/search/?query=%22cognitive+radio%22&searchtype=all&source=header), [signal processing research](https://arxiv.org/list/eess.SP/recent)

197-200: **Cybersecurity**: It's probably impossible to map out the giant rabbithole that information security has become in the last three or four decades, but it's probably not a bad idea to try to develop your own prioritized list of some of the best blogs, repositories, newsletters, and other infosec resources. Spending a few days developing a prioritized list that one might come back to on a weekly basis is more than enough to immerse anyone in the truly hysterical topic of cybersecurity.

1. [Schneier on Security](https://www.schneier.com/) -- Easily the most level-headed and sanely PROFESSIONAL resource on information security. As a general rule, at least one a week or maybe more frequently everyone should read [***Schneier On Security***](https://www.schneier.com/). We all know that infosec is something that we should be more aware of ... the reason that normal, well-adjusted people tend shy away from this topic is that, unfortunately, MOST OF, but not quite all of material on information security is like antivirus software being worse than viruses ... people shy away from infosec blogs because they don't want to catch infosec mindrot. EXCEPT FOR [Schneier on Security](https://www.schneier.com/) most of the ad-heavy content, which inherently needy and likely to be insecure or even quasi-malicious trackering malware, out there is mostly just out-and-out hysteria barrage coated in disgusting slop of stewed fear-mongering grease, ie "*THIS* ***new threat*** *is something you need to be totally terrified of and you're probably already fucked, but it's too slippery for you to grasp, so get yourself some of our X or book me for a seminar immediately.*"

2. [OWASP (Open Web Application Security Project)](https://github.com/OWASP) is a nonprofit foundation with tens of thousands of members working to improve the security of software with community-led open source projects including code, documentation, and standards. Different materials might be particular useful to people trying to learn as much as possible as quickly as possible about security. OWASP provides a wealth of resources, including: [Cheat Sheet Series](https://cheatsheetseries.owasp.org/IndexASVS.html) [Software Assurance Maturity Model](https://owasp.org/www-project-samm/)

3. [HackerRepo.org](https://github.com/The-Art-of-Hacking/h4cker) by [Omar Santos](https://github.com/santosomar) -- includes thousands of resources related to ethical hacking, bug bounties, digital forensics and incident response (DFIR), artificial intelligence security, vulnerability research, exploit development, reverse engineering, and supplemental materials to support the bodies of knowledge for relevant infosec Certifications.

4. [SecLists.Org Security Mailing List Archive](http://seclists.org/) -- everyone knows that the latest news and exploits are not found on any web site. The cutting edge in security research is and will continue to be the full disclosure mailing lists such as Bugtraq. SecLists provides web archives and RSS feeds. You can browse the individual lists or search them all using the Site Search box.

5. [Exploit Database](https://www.exploit-db.com/) non-profit project that is maintained and provided as a public service by the [OffSec training and pentesting company](https://www.offsec.com/products/) as one of its [open source community projects](https://www.offsec.com/community-projects/). 

6. [SANS Internet Storm Center(ISC)](https://isc.sans.edu/), part of the [SANS Technology Institute](https://www.sans.edu/), ISC is a free, community-driven infosec defensive service offering daily diaries, podcasts, and many different initiatives.

7. [Packet Storm Security](https://packetstormsecurity.com/) provides around-the-clock information and tools in order to help mitigate both personal data and fiscal loss on a global scale. As new information surfaces, Packet Storm releases everything immediately through it's RSS feeds, Twitter, and Facebook.



4. [The Hacker News](https://thehackernews.com/)
5. [Threatpost](https://threatpost.com/)


11. Security Weekly - https://securityweekly.com/
12. Risky Business Podcast - https://risky.biz/
13. Troy Hunt's Blog - https://www.troyhunt.com/
14. Graham Cluley - https://grahamcluley.com/
15. Naked Security (Sophos) - https://nakedsecurity.sophos.com/
16. CSO Online - https://www.csoonline.com/
17. Bleeping Computer - https://www.bleepingcomputer.com/
18. Daniel Miessler - https://danielmiessler.com/
19. Reddit r/netsec - https://www.reddit.com/r/netsec/
20. GitHub Security Lab - https://securitylab.github.com/
21. Google Project Zero - https://googleprojectzero.blogspot.com/
22. Microsoft Security Response Center - https://msrc-blog.microsoft.com/
23. AWS Security Blog - https://aws.amazon.com/blogs/security/
24. Black Hat Conference Media - https://www.blackhat.com/html/media.html
25. DEF CON Media Server - https://media.defcon.org/

26. [Krebs on Security](https://krebsonsecurity.com/) covers a wide range of topics, from general security news and analysis to technical details on vulnerabilities, exploits, and defensive measures. 
3. [Dark Reading](https://www.darkreading.com/)

There are different terms and key words that are important in [cybersurity for IoT](https://www.nist.gov/itl/applied-cybersecurity/nist-cybersecurity-iot-program), which is related to but it's focus is necessarily different than [general cybersecurity](https://www.nist.gov/blogs/cybersecurity-insights) which is focused on humans, social engineering, identity theft and malevolent actors that tend to be financially motivated. 

[Encryption](https://en.wikipedia.org/wiki/Encryption) is always an infinitely beguiling topic to strategists; this will be true even after we understand the inevitability of its **eventual** vulnerability to things like [quantum computing and communication](https://en.wikipedia.org/wiki/Timeline_of_quantum_computing_and_communication) and meta-algorithmic combinations of technological [flanking strategies](https://en.wikipedia.org/wiki/List_of_military_strategies_and_concepts) which exploit both [quantum coherence](https://en.wikipedia.org/wiki/Coherence_(physics)#Quantum_coherence) and [quantum decoherence](https://en.wikipedia.org/wiki/Quantum_decoherence). It will always be possible to hide things in plain sight or to use multiplexed [steganography] to convey information within riddles within enigmas within other message channels. 

This is why security specialists study and debate topics like multi-factor [authentication](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html), [authorization](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html), [digital signatures](https://cloud.google.com/kms/docs/digital-signatures), [cryptographic storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html) ... *the OLD ways will always keep getting figured out by the bad guys* ***FASTER than the good guys can come up with NEW ways*** ... so even though we are aware of things like [glaring PGP deficiencies](https://www.latacora.com/blog/2019/07/16/the-pgp-problem/) and [why PGP should just die](https://blog.cryptographyengineering.com/2014/08/13/whats-matter-with-pgp/), there will always be a new scramble to move on to something slightly more secure, such as [signing arbitrary data with your SSH keys](https://www.agwa.name/blog/post/ssh_signatures) ... which in a meta-sense is likely continually changing your pas$word by a single letter or changing the locks on your house but still living in a way that attracts lock-picking intruders.

